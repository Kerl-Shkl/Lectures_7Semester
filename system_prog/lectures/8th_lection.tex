%! TEX root = ../main.tex

\section{Лекция от 04.02.2023}

\subsection{Синхрониазция с помощью семафоров}

У семафора больше двух состояний. Вводится максимальное число счетчика семафора,
назовем его \verb!c!, и вводится два элементарных действия (примитива).\\
{\ttfamily (Этапы компиляции: Лексический разбор $\to$ Синтаксический анализ
(строим синтаксическое дерево) $\to$ Семантический)}\\ 
Две операции:
\begin{enumerate}
  \item Увелечение счетчика \verb!c! на заданную велечину (атомарная операция).
  \item Уменьшение счетчика \verb!c! на заданную велечину (атомарная операция). Если
    \verb!c! равна 0, то сделать ее меньше нуля невозможно.
\end{enumerate}\par

\textbf{Пример:}\par
Есть три принтера. Вводится семафор \verb!c! счетчиком 3. Если \verb!c! равно 0, то все
принтеры заняты. Если \verb!c! равна 1, то 1 принтер свободен\dots 
Каждый раз при обращениии к печати счетчик \verb!c! уменьшается на 1. 

Если семафор может принимать значения только 0 или 1, он приравнивается к
блокирующей переменной.

При создании семафора для него задается максимальное число его счетчика. 

Есть функция \verb!ReleaseSemaphore!, которая позволяет увеличивать счетчик
семафора.
\begin{verbatim}
  BOOL ReleaseSemaphore(
          HANDLE hSem,
          LONG lReleaseCount,
          PLONG plPreviousCount );
\end{verbatim}

При завершении любой функции ожидания, которая обращается к семафору, число в
счетчике уменьшается на единичку. Пока \verb!c! больше 0, семафор находится в
сигнальном состоянии.

Объект семафор создается вызовом функции \verb!CreateSemaphore!.
\begin{verbatim}
  HANDLE CreateSemaphore(
          PSECURITY_ATTRIBUTE psa,
          LONG lInitialCount,
          LONG lMaximumCount,
          PCTSTR pszName );
\end{verbatim}

\begin{itemize}
  \item \verb!lInitialCount! --- Начальное значение счетчика.
  \item \verb!lMaximumCount! --- Максимальное значение счетчика.
  \item \verb!pszName! --- Имя объекта ядра.
\end{itemize}

\begin{verbatim}
  CreateSemaphore(...);
  if (GetLastError() == ERROR_ALREADY_EXISTS) {
    
  }
\end{verbatim}

Пример, как получить текущее значение счетчика семафора:
\begin{verbatim}
  long N = MaximumCount; // Зачем в N заносить MaximumCount я не знаю
  if (ReleaseSemaphore(s, 1, &N)) {
    WaitForSingleObject(s,1);
  }
\end{verbatim}

Пример работы с семфорами:\\
Поток 1 процесс A:
\begin{verbatim}
  HADLE s = CreateSemaphore(NULL, MaximumCount, MaximumCount, "Sem1");
\end{verbatim}
Поток 2 процесс B;
\begin{verbatim}
  HANDLE s = OpenSemaphore(SEMAPHORE_ALL_ACCESS,
                           TRUE, "Sem1");
  DWORD TimeOut = 2000;
  ...
  // Запрос ресурса 
  DWORD Result = WaitForSingleObject(S, TimeOut);
  if (Resul == WAIT_OBJECT_0) {
    // Действия с ресурсом
    ReleaseSemaphore(s, 1, NULL);
  } else {
    // Вывод того, что происходит
  }
\end{verbatim}

\subsection{Mutex}
Чем mutex лучше предыдущих объектов --- тем, что mutex запоминает поток, в
котором вызывается. Mutex гарантирует потокам взаимоисключающий доступ к
разделяемому ресурсу. В нем есть:
\begin{enumerate}
  \item Счетчик числа пользователей.
  \item Счетчик числа рекурсии.
  \item ID потока.
\end{enumerate}

Если ID потока равно 0, значит mutex находится в сигнальном состоянии. Иначе
mutex захвачен одним потоком и находится в несигнальном состоянии.

\paragraph{Функции для работы с mutex.}\mbox{}\par
Поток получает доступ к mutex, вызывая одну из функций ожидания с передачей ей
дескриптора mutex. Если функция ожидания опрделяет, что ID потока не равен 0,
вызывающий поток переходит в состояние ожидания. Когда ID потока обнуляется в
дескриптор, записывается ID ожидающего потока и счетчику рекурсии присваивается
1.

Для mutex сделано одно исключение: если ID потока в дескрипторе mutex'а
совпадает с ID потока, который вызвал функцию ожидания для этого mutex'a, то
система выделяет потоку процессорное время, хотя mutex еще занят. Счетчик
рекурсии содержит количество захватов одного mutex'a потоком. Когда ожидания
mutex'а потоком успешно завершается, поток получает монопольный доступ к
ресурсу, а все остальные потоки, которые запрашивают этот ресурс переходят в
состояние ожидания.

Функция \verb!BOOL ReleaseMutex(HANDLE hMutex)! уменьшает счетчик рекурсии на
единицу. Если поток захватывал mutex $n$ раз, то функция \verb!ReleaseMutex!
доллжна быть вызвана $n$ раз. 

Если какой-либо другй поток попытается вызвать функцию \verb!ReleaseMutex!, то
функция не сработает и вернет \verb!FALSE!. 

Если какой-либо поток завершается не освободив mutex, то считается, что
произошел отказ от mutex, и система переводит его в сигнальное состояние.

Функция \verb!OpenMutex! позволяет открыть mutex с именем \verb!pszName!.
fdwAccess может принимать два значения \dots
